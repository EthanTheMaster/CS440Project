package test;

import solver.*;

import java.util.*;

public class StressTester {
    private static final double EPSILON = 0.0000001;

    /**
     * Stress testing method to evaluate the performance of the linear program
     * solver. This method generates a flow network parameterized by k "layers"
     * and n nodes per layer with each layer being fully connected with the next
     * layer. Each edge weight is randomly generated and a max flow is computed
     * across this network. The flow generated by the linear program is validated
     * using the Max-Flow Min-Cut Theorem.
     * @param layerSize the number of nodes per layer
     * @param numLayers the number of layers
     * @return the time it took to compute the max flow in milliseconds
     * @throws Exception if the flow generated failed to be optimal by Max-Flow
     * Min-Cut theorem
     */
    public static long maxFlow(int layerSize, int numLayers) throws Exception {
        LinearProgram p = new LinearProgram();

        // network[u][v] holds the capacity of edge (u, v)
        HashMap<String, HashMap<String, Double>> network = new HashMap<>();
        HashMap<String, Variable> flows = new HashMap<>();
        String s = "s";
        String t = "t";

        String flowFormat = "f.%s.%s";

        Set<String> lastLayer = new HashSet<>(Collections.singletonList(s));
        for (int l = 0; l < numLayers; l++) {
            // Create next layer
            Set<String> nextLayer = new HashSet<>();
            for (int i = 0; i < layerSize; i++) {
                String vertexName = String.format("L%d_V%d", l, i);
                nextLayer.add(vertexName);
            }

            // Create connections between last and next layer
            for (String u : lastLayer) {
                HashMap<String, Double> neighbors = new HashMap<>();
                for (String v : nextLayer) {
                    double capacity = new Random().nextDouble()*1000.0 + 1.0;
                    neighbors.put(v, capacity);

                    String flowName = String.format(flowFormat, u, v);
                    flows.put(flowName, p.registerVariable(flowName, 0.0, capacity));
                }
                network.put(u, neighbors);
            }

            lastLayer = nextLayer;
        }

        // Connect last layer to the sink vertex
        for (String u : lastLayer) {
            HashMap<String, Double> neighbors = new HashMap<>();
            double capacity = new Random().nextDouble()*1000.0 + 1.0;
            neighbors.put(t, capacity);
            network.put(u, neighbors);

            String flowName = String.format(flowFormat, u, t);
            flows.put(flowName, p.registerVariable(flowName, 0.0, capacity));
        }
        network.put(t, new HashMap<>());

        // Establish flow conservation constraints
        for (String v : network.keySet()) {
            if (!v.equals(s) && !v.equals(t)) {
                ArrayList<Variable> variables = new ArrayList<>();
                ArrayList<Double> weights = new ArrayList<>();
                // Look at all outflows
                for (String w : network.get(v).keySet()) {
                    String flowName = String.format(flowFormat, v, w);
                    variables.add(flows.get(flowName));
                    weights.add(1.0);
                }
                // Look at all inflows
                for (String u : network.keySet()) {
                    if (network.get(u).containsKey(v)) {
                        String flowName = String.format(flowFormat, u, v);
                        variables.add(flows.get(flowName));
                        weights.add(-1.0);
                    }
                }
                p.addConstraint(new Constraint(variables, weights, Relation.EQ, 0.0));
            }
        }

        // Establish optimization
        ArrayList<Variable> variables = new ArrayList<>();
        ArrayList<Double> weights = new ArrayList<>();
        // Look at all outflows from the source
        for (String v : network.get(s).keySet()) {
            String flowName = String.format(flowFormat, s, v);
            variables.add(flows.get(flowName));
            weights.add(1.0);
        }
        p.setObjective(new ObjectiveFunction(ObjectiveGoal.MAXIMIZE, variables, weights));

        // Start timing the solve time
        long start = System.currentTimeMillis();
        p.solve();
        long time = System.currentTimeMillis() - start;

        // Validate the solution by checking if there is an augmenting path in the residual network
        // Max-Flow Min-Cut theorem says that we have a max flow iff there is no augmenting path
        // in the residual network
        HashMap<String, HashMap<String, Double>> residualNetwork = new HashMap<>();
        HashMap<String, String> colors = new HashMap<>();
        String WHITE = "WHITE";
        String GRAY = "GRAY";
        String BLACK = "BLACK";

        for (String v : network.keySet()) {
            residualNetwork.put(v, new HashMap<>());
            colors.put(v, WHITE);
        }

        for (String u : network.keySet()) {
            for (String v : network.get(u).keySet()) {
                double capacity = network.get(u).get(v);
                Variable flowVariable = flows.get(String.format(flowFormat, u, v));
                Optional<Double> flow = p.evaluateVariable(flowVariable);
                if (flow.isPresent()) {
                    // Parallel edge
                    if (Math.abs(capacity - flow.get()) > EPSILON) {
                        residualNetwork.get(u).put(v, capacity - flow.get());
                    }
                    // Antiparallel edge
                    if (Math.abs(flow.get()) > EPSILON) {
                        residualNetwork.get(v).put(u, flow.get());
                    }
                } else {
                    throw new Exception("Flow was not assigned!");
                }
            }
        }

        // Perform DFS to find augmenting path
        ArrayDeque<String> stack = new ArrayDeque<>();
        stack.push(s);
        while (!stack.isEmpty()) {
            String u = stack.pop();
            colors.put(u, GRAY);
            for (String v : residualNetwork.get(u).keySet()) {
                if (colors.get(v).equals(WHITE)) {
                    stack.push(v);
                }
            }
            colors.put(u, BLACK);
        }
        // The sink vertex was visited so DFS found a path from the source to sink
        if (colors.get(t).equals("BLACK")) {
            throw new Exception("Found an augmenting path!");
        }

        return time;
    }
}
